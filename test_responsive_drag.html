<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>レスポンシブドラッグ&ドロップ テスト</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
      }
      .test-item {
        background: white;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 15px;
        margin: 10px 0;
        cursor: grab;
        user-select: none;
        transition: opacity 0.3s;
      }
      .test-item.dragging {
        opacity: 0.5;
      }
      .test-item.drag-over {
        border-color: #4a90e2;
        background: #f0f8ff;
      }
      .info {
        background: #e3f2fd;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
      }
      .btn {
        padding: 8px 16px;
        font-size: 0.9rem;
        min-width: 60px;
        margin: 5px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      .btn-edit {
        background: #28a745;
        color: white;
      }
      .btn-delete {
        background: #dc3545;
        color: white;
      }
      .btn-complete {
        background: #17a2b8;
        color: white;
      }
      .test-actions {
        display: flex;
        gap: 10px;
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <div class="info">
      <h2>レスポンシブドラッグ&ドロップ テスト</h2>
      <p>
        このページで、タッチイベントによるドラッグ&ドロップをテストできます。
      </p>
      <p><strong>テスト方法:</strong></p>
      <ul>
        <li>デスクトップ: マウスでドラッグ&ドロップ</li>
        <li>モバイル/タブレット: 長押ししてドラッグ</li>
        <li>ブラウザの開発者ツール: デバイスモードでテスト</li>
      </ul>
    </div>

    <div id="test-list">
      <div class="test-item" data-id="1" draggable="true">
        <div>Todo 1</div>
        <div class="test-actions">
          <button class="btn btn-edit">編集</button>
          <button class="btn btn-delete">削除</button>
          <button class="btn btn-complete">完了</button>
        </div>
      </div>
      <div class="test-item" data-id="2" draggable="true">
        <div>Todo 2</div>
        <div class="test-actions">
          <button class="btn btn-edit">編集</button>
          <button class="btn btn-delete">削除</button>
          <button class="btn btn-complete">完了</button>
        </div>
      </div>
      <div class="test-item" data-id="3" draggable="true">
        <div>Todo 3</div>
        <div class="test-actions">
          <button class="btn btn-edit">編集</button>
          <button class="btn btn-delete">削除</button>
          <button class="btn btn-complete">完了</button>
        </div>
      </div>
      <div class="test-item" data-id="4" draggable="true">
        <div>Todo 4</div>
        <div class="test-actions">
          <button class="btn btn-edit">編集</button>
          <button class="btn btn-delete">削除</button>
          <button class="btn btn-complete">完了</button>
        </div>
      </div>
    </div>

    <div
      id="log"
      style="
        margin-top: 20px;
        padding: 10px;
        background: #f5f5f5;
        border-radius: 4px;
      "
    >
      <strong>ログ:</strong>
      <div id="log-content"></div>
    </div>

    <script>
      const todoList = document.getElementById("test-list");
      const logContent = document.getElementById("log-content");

      let draggedElement = null;
      let touchStartY = 0;
      let touchCurrentY = 0;

      function log(message) {
        const time = new Date().toLocaleTimeString();
        logContent.innerHTML += `<div>[${time}] ${message}</div>`;
        logContent.scrollTop = logContent.scrollHeight;
      }

      // マウスドラッグ（デスクトップ）
      todoList.addEventListener("dragstart", function (e) {
        if (e.target.closest(".test-actions") || e.target.closest(".btn")) {
          e.preventDefault();
          return;
        }

        if (e.target.classList.contains("test-item")) {
          draggedElement = e.target;
          e.target.style.opacity = "0.5";
          e.dataTransfer.effectAllowed = "move";
          log("ドラッグ開始（マウス）");
        }
      });

      todoList.addEventListener("dragover", function (e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";

        if (!draggedElement) return;

        const afterElement = getDragAfterElement(todoList, e.clientY);
        const allItems = todoList.querySelectorAll(".test-item");
        allItems.forEach((item) => item.classList.remove("drag-over"));

        if (afterElement == null) {
          todoList.appendChild(draggedElement);
        } else {
          todoList.insertBefore(draggedElement, afterElement);
          if (afterElement !== draggedElement) {
            afterElement.classList.add("drag-over");
          }
        }
      });

      todoList.addEventListener("dragend", function (e) {
        if (e.target.classList.contains("test-item")) {
          e.target.style.opacity = "1";
          const allItems = todoList.querySelectorAll(".test-item");
          allItems.forEach((item) => item.classList.remove("drag-over"));

          const order = Array.from(todoList.children).map((item) =>
            item.getAttribute("data-id")
          );
          log(`ドラッグ終了（マウス）: 順序 = [${order.join(", ")}]`);
          draggedElement = null;
        }
      });

      // タッチドラッグ（モバイル）
      todoList.addEventListener(
        "touchstart",
        function (e) {
          if (e.target.closest(".test-actions") || e.target.closest(".btn")) {
            return;
          }

          const item = e.target.closest(".test-item");
          if (item) {
            draggedElement = item;
            touchStartY = e.touches[0].clientY;
            touchCurrentY = touchStartY;
            item.style.opacity = "0.5";
            item.style.transition = "none";
            log(`タッチ開始: Todo ${item.getAttribute("data-id")}`);
          }
        },
        { passive: true }
      );

      todoList.addEventListener(
        "touchmove",
        function (e) {
          if (!draggedElement) return;

          e.preventDefault();
          touchCurrentY = e.touches[0].clientY;
          const deltaY = touchCurrentY - touchStartY;

          draggedElement.style.transform = `translateY(${deltaY}px)`;

          const afterElement = getDragAfterElement(todoList, touchCurrentY);
          const allItems = todoList.querySelectorAll(".test-item");
          allItems.forEach((item) => {
            if (item !== draggedElement) {
              item.classList.remove("drag-over");
            }
          });

          if (afterElement && afterElement !== draggedElement) {
            afterElement.classList.add("drag-over");
            if (afterElement.nextSibling !== draggedElement) {
              todoList.insertBefore(draggedElement, afterElement);
            }
          } else if (
            afterElement === null &&
            draggedElement !== todoList.lastElementChild
          ) {
            todoList.appendChild(draggedElement);
          }
        },
        { passive: false }
      );

      todoList.addEventListener(
        "touchend",
        function (e) {
          if (!draggedElement) return;

          const item = draggedElement;
          item.style.opacity = "1";
          item.style.transform = "";
          item.style.transition = "";

          const order = Array.from(todoList.children).map((item) =>
            item.getAttribute("data-id")
          );
          log(`タッチ終了: 順序 = [${order.join(", ")}]`);

          const allItems = todoList.querySelectorAll(".test-item");
          allItems.forEach((item) => item.classList.remove("drag-over"));

          draggedElement = null;
          touchStartY = 0;
          touchCurrentY = 0;
        },
        { passive: true }
      );

      function getDragAfterElement(container, y) {
        const draggableElements = [
          ...container.querySelectorAll(".test-item:not(.dragging)"),
        ];

        return draggableElements.reduce(
          (closest, child) => {
            if (child === draggedElement) return closest;
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;

            if (offset < 0 && offset > closest.offset) {
              return { offset: offset, element: child };
            } else {
              return closest;
            }
          },
          { offset: Number.NEGATIVE_INFINITY }
        ).element;
      }

      log("テストページが読み込まれました");
    </script>
  </body>
</html>
